import { Directive, EventEmitter, Input, Output } from '@angular/core';
import { ngbRunTransition } from '../util/transition/ngbTransition';
import { ngbCollapsingTransition } from '../util/transition/ngbCollapseTransition';
import * as i0 from "@angular/core";
import * as i1 from "./collapse-config";
/**
 * A directive to provide a simple way of hiding and showing elements on the
 * page.
 */
export class NgbCollapse {
    constructor(_element, config, _zone) {
        this._element = _element;
        this._zone = _zone;
        /**
         * Flag used to track if the collapse setter is invoked during initialization
         * or not. This distinction is made in order to avoid running the transition during initialization.
         */
        this._afterInit = false;
        this._isCollapsed = false;
        this.ngbCollapseChange = new EventEmitter();
        /**
         * An event emitted when the collapse element is shown, after the transition.
         * It has no payload.
         *
         * @since 8.0.0
         */
        this.shown = new EventEmitter();
        /**
         * An event emitted when the collapse element is hidden, after the transition.
         * It has no payload.
         *
         * @since 8.0.0
         */
        this.hidden = new EventEmitter();
        this.animation = config.animation;
        this.horizontal = config.horizontal;
    }
    /**
     * If `true`, will collapse the element or show it otherwise.
     */
    set collapsed(isCollapsed) {
        if (this._isCollapsed !== isCollapsed) {
            this._isCollapsed = isCollapsed;
            if (this._afterInit) {
                this._runTransitionWithEvents(isCollapsed, this.animation);
            }
        }
    }
    ngOnInit() {
        this._runTransition(this._isCollapsed, false);
        this._afterInit = true;
    }
    /**
     * Triggers collapsing programmatically.
     *
     * If there is a collapsing transition running already, it will be reversed.
     * If the animations are turned off this happens synchronously.
     *
     * @since 8.0.0
     */
    toggle(open = this._isCollapsed) {
        this.collapsed = !open;
        this.ngbCollapseChange.next(this._isCollapsed);
    }
    _runTransition(collapsed, animation) {
        return ngbRunTransition(this._zone, this._element.nativeElement, ngbCollapsingTransition, {
            animation,
            runningTransition: 'stop',
            context: { direction: collapsed ? 'hide' : 'show', dimension: this.horizontal ? 'width' : 'height' },
        });
    }
    _runTransitionWithEvents(collapsed, animation) {
        this._runTransition(collapsed, animation).subscribe(() => {
            if (collapsed) {
                this.hidden.emit();
            }
            else {
                this.shown.emit();
            }
        });
    }
}
NgbCollapse.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.6", ngImport: i0, type: NgbCollapse, deps: [{ token: i0.ElementRef }, { token: i1.NgbCollapseConfig }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
NgbCollapse.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.6", type: NgbCollapse, selector: "[ngbCollapse]", inputs: { animation: "animation", collapsed: ["ngbCollapse", "collapsed"], horizontal: "horizontal" }, outputs: { ngbCollapseChange: "ngbCollapseChange", shown: "shown", hidden: "hidden" }, host: { properties: { "class.collapse-horizontal": "horizontal" } }, exportAs: ["ngbCollapse"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.6", ngImport: i0, type: NgbCollapse, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngbCollapse]',
                    exportAs: 'ngbCollapse',
                    host: { '[class.collapse-horizontal]': 'horizontal' },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.NgbCollapseConfig }, { type: i0.NgZone }]; }, propDecorators: { animation: [{
                type: Input
            }], collapsed: [{
                type: Input,
                args: ['ngbCollapse']
            }], ngbCollapseChange: [{
                type: Output
            }], horizontal: [{
                type: Input
            }], shown: [{
                type: Output
            }], hidden: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGFwc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29sbGFwc2UvY29sbGFwc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBYyxZQUFZLEVBQUUsS0FBSyxFQUFrQixNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDcEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQUduRjs7O0dBR0c7QUFNSCxNQUFNLE9BQU8sV0FBVztJQXlEdkIsWUFBb0IsUUFBb0IsRUFBRSxNQUF5QixFQUFVLEtBQWE7UUFBdEUsYUFBUSxHQUFSLFFBQVEsQ0FBWTtRQUFxQyxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBOUMxRjs7O1dBR0c7UUFDSyxlQUFVLEdBQUcsS0FBSyxDQUFDO1FBRW5CLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBZW5CLHNCQUFpQixHQUFHLElBQUksWUFBWSxFQUFXLENBQUM7UUFTMUQ7Ozs7O1dBS0c7UUFDTyxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUUzQzs7Ozs7V0FLRztRQUNPLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBUSxDQUFDO1FBRzNDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7SUFDckMsQ0FBQztJQXpDRDs7T0FFRztJQUNILElBQ0ksU0FBUyxDQUFDLFdBQW9CO1FBQ2pDLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxXQUFXLEVBQUU7WUFDdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7WUFDaEMsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNwQixJQUFJLENBQUMsd0JBQXdCLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUMzRDtTQUNEO0lBQ0YsQ0FBQztJQWdDRCxRQUFRO1FBQ1AsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLE9BQWdCLElBQUksQ0FBQyxZQUFZO1FBQ3ZDLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDdkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVPLGNBQWMsQ0FBQyxTQUFrQixFQUFFLFNBQWtCO1FBQzVELE9BQU8sZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsRUFBRSx1QkFBdUIsRUFBRTtZQUN6RixTQUFTO1lBQ1QsaUJBQWlCLEVBQUUsTUFBTTtZQUN6QixPQUFPLEVBQUUsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUU7U0FDcEcsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVPLHdCQUF3QixDQUFDLFNBQWtCLEVBQUUsU0FBa0I7UUFDdEUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN4RCxJQUFJLFNBQVMsRUFBRTtnQkFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ25CO2lCQUFNO2dCQUNOLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDbEI7UUFDRixDQUFDLENBQUMsQ0FBQztJQUNKLENBQUM7O3dHQWhHVyxXQUFXOzRGQUFYLFdBQVc7MkZBQVgsV0FBVztrQkFMdkIsU0FBUzttQkFBQztvQkFDVixRQUFRLEVBQUUsZUFBZTtvQkFDekIsUUFBUSxFQUFFLGFBQWE7b0JBQ3ZCLElBQUksRUFBRSxFQUFFLDZCQUE2QixFQUFFLFlBQVksRUFBRTtpQkFDckQ7c0pBVVMsU0FBUztzQkFBakIsS0FBSztnQkFjRixTQUFTO3NCQURaLEtBQUs7dUJBQUMsYUFBYTtnQkFVVixpQkFBaUI7c0JBQTFCLE1BQU07Z0JBT0UsVUFBVTtzQkFBbEIsS0FBSztnQkFRSSxLQUFLO3NCQUFkLE1BQU07Z0JBUUcsTUFBTTtzQkFBZixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBuZ2JSdW5UcmFuc2l0aW9uIH0gZnJvbSAnLi4vdXRpbC90cmFuc2l0aW9uL25nYlRyYW5zaXRpb24nO1xuaW1wb3J0IHsgbmdiQ29sbGFwc2luZ1RyYW5zaXRpb24gfSBmcm9tICcuLi91dGlsL3RyYW5zaXRpb24vbmdiQ29sbGFwc2VUcmFuc2l0aW9uJztcbmltcG9ydCB7IE5nYkNvbGxhcHNlQ29uZmlnIH0gZnJvbSAnLi9jb2xsYXBzZS1jb25maWcnO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIHByb3ZpZGUgYSBzaW1wbGUgd2F5IG9mIGhpZGluZyBhbmQgc2hvd2luZyBlbGVtZW50cyBvbiB0aGVcbiAqIHBhZ2UuXG4gKi9cbkBEaXJlY3RpdmUoe1xuXHRzZWxlY3RvcjogJ1tuZ2JDb2xsYXBzZV0nLFxuXHRleHBvcnRBczogJ25nYkNvbGxhcHNlJyxcblx0aG9zdDogeyAnW2NsYXNzLmNvbGxhcHNlLWhvcml6b250YWxdJzogJ2hvcml6b250YWwnIH0sXG59KVxuZXhwb3J0IGNsYXNzIE5nYkNvbGxhcHNlIGltcGxlbWVudHMgT25Jbml0IHtcblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgY29sbGFwc2Ugd2lsbCBiZSBhbmltYXRlZC5cblx0ICpcblx0ICogQW5pbWF0aW9uIGlzIHRyaWdnZXJlZCBvbmx5IHdoZW4gY2xpY2tlZCBvbiB0cmlnZ2VyaW5nIGVsZW1lbnRcblx0ICogb3IgdmlhIHRoZSBgLnRvZ2dsZSgpYCBmdW5jdGlvblxuXHQgKlxuXHQgKiBAc2luY2UgOC4wLjBcblx0ICovXG5cdEBJbnB1dCgpIGFuaW1hdGlvbjtcblxuXHQvKipcblx0ICogRmxhZyB1c2VkIHRvIHRyYWNrIGlmIHRoZSBjb2xsYXBzZSBzZXR0ZXIgaXMgaW52b2tlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb25cblx0ICogb3Igbm90LiBUaGlzIGRpc3RpbmN0aW9uIGlzIG1hZGUgaW4gb3JkZXIgdG8gYXZvaWQgcnVubmluZyB0aGUgdHJhbnNpdGlvbiBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG5cdCAqL1xuXHRwcml2YXRlIF9hZnRlckluaXQgPSBmYWxzZTtcblxuXHRwcml2YXRlIF9pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIHdpbGwgY29sbGFwc2UgdGhlIGVsZW1lbnQgb3Igc2hvdyBpdCBvdGhlcndpc2UuXG5cdCAqL1xuXHRASW5wdXQoJ25nYkNvbGxhcHNlJylcblx0c2V0IGNvbGxhcHNlZChpc0NvbGxhcHNlZDogYm9vbGVhbikge1xuXHRcdGlmICh0aGlzLl9pc0NvbGxhcHNlZCAhPT0gaXNDb2xsYXBzZWQpIHtcblx0XHRcdHRoaXMuX2lzQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQ7XG5cdFx0XHRpZiAodGhpcy5fYWZ0ZXJJbml0KSB7XG5cdFx0XHRcdHRoaXMuX3J1blRyYW5zaXRpb25XaXRoRXZlbnRzKGlzQ29sbGFwc2VkLCB0aGlzLmFuaW1hdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0QE91dHB1dCgpIG5nYkNvbGxhcHNlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIHdpbGwgY29sbGFwc2UgaG9yaXpvbnRhbGx5LlxuXHQgKlxuXHQgKiBAc2luY2UgMTMuMS4wXG5cdCAqL1xuXHRASW5wdXQoKSBob3Jpem9udGFsOiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbGxhcHNlIGVsZW1lbnQgaXMgc2hvd24sIGFmdGVyIHRoZSB0cmFuc2l0aW9uLlxuXHQgKiBJdCBoYXMgbm8gcGF5bG9hZC5cblx0ICpcblx0ICogQHNpbmNlIDguMC4wXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2hvd24gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cblx0LyoqXG5cdCAqIEFuIGV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY29sbGFwc2UgZWxlbWVudCBpcyBoaWRkZW4sIGFmdGVyIHRoZSB0cmFuc2l0aW9uLlxuXHQgKiBJdCBoYXMgbm8gcGF5bG9hZC5cblx0ICpcblx0ICogQHNpbmNlIDguMC4wXG5cdCAqL1xuXHRAT3V0cHV0KCkgaGlkZGVuID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsIGNvbmZpZzogTmdiQ29sbGFwc2VDb25maWcsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xuXHRcdHRoaXMuYW5pbWF0aW9uID0gY29uZmlnLmFuaW1hdGlvbjtcblx0XHR0aGlzLmhvcml6b250YWwgPSBjb25maWcuaG9yaXpvbnRhbDtcblx0fVxuXG5cdG5nT25Jbml0KCkge1xuXHRcdHRoaXMuX3J1blRyYW5zaXRpb24odGhpcy5faXNDb2xsYXBzZWQsIGZhbHNlKTtcblx0XHR0aGlzLl9hZnRlckluaXQgPSB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIGNvbGxhcHNpbmcgcHJvZ3JhbW1hdGljYWxseS5cblx0ICpcblx0ICogSWYgdGhlcmUgaXMgYSBjb2xsYXBzaW5nIHRyYW5zaXRpb24gcnVubmluZyBhbHJlYWR5LCBpdCB3aWxsIGJlIHJldmVyc2VkLlxuXHQgKiBJZiB0aGUgYW5pbWF0aW9ucyBhcmUgdHVybmVkIG9mZiB0aGlzIGhhcHBlbnMgc3luY2hyb25vdXNseS5cblx0ICpcblx0ICogQHNpbmNlIDguMC4wXG5cdCAqL1xuXHR0b2dnbGUob3BlbjogYm9vbGVhbiA9IHRoaXMuX2lzQ29sbGFwc2VkKSB7XG5cdFx0dGhpcy5jb2xsYXBzZWQgPSAhb3Blbjtcblx0XHR0aGlzLm5nYkNvbGxhcHNlQ2hhbmdlLm5leHQodGhpcy5faXNDb2xsYXBzZWQpO1xuXHR9XG5cblx0cHJpdmF0ZSBfcnVuVHJhbnNpdGlvbihjb2xsYXBzZWQ6IGJvb2xlYW4sIGFuaW1hdGlvbjogYm9vbGVhbikge1xuXHRcdHJldHVybiBuZ2JSdW5UcmFuc2l0aW9uKHRoaXMuX3pvbmUsIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgbmdiQ29sbGFwc2luZ1RyYW5zaXRpb24sIHtcblx0XHRcdGFuaW1hdGlvbixcblx0XHRcdHJ1bm5pbmdUcmFuc2l0aW9uOiAnc3RvcCcsXG5cdFx0XHRjb250ZXh0OiB7IGRpcmVjdGlvbjogY29sbGFwc2VkID8gJ2hpZGUnIDogJ3Nob3cnLCBkaW1lbnNpb246IHRoaXMuaG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JyB9LFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBfcnVuVHJhbnNpdGlvbldpdGhFdmVudHMoY29sbGFwc2VkOiBib29sZWFuLCBhbmltYXRpb246IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9ydW5UcmFuc2l0aW9uKGNvbGxhcHNlZCwgYW5pbWF0aW9uKS5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0aWYgKGNvbGxhcHNlZCkge1xuXHRcdFx0XHR0aGlzLmhpZGRlbi5lbWl0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNob3duLmVtaXQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuIl19